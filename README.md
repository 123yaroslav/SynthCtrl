# План разработки библиотеки Synthetic Control

## 1. Архитектура библиотеки

### 1.1 Структура проекта
```
new_library/
├── synthetic_control/
│   ├── __init__.py
│   ├── base.py           # Базовый класс SyntheticControl
│   ├── estimators.py     # Реализации различных оценщиков
│   ├── utils.py          # Вспомогательные функции
│   └── visualization.py  # Функции для визуализации
├── tests/
│   ├── __init__.py
│   ├── test_base.py
│   ├── test_estimators.py
│   ├── test_utils.py
│   └── test_visualization.py
├── examples/
│   └── basic_usage.ipynb
├── setup.py
├── requirements.txt
└── README.md
```

### 1.2 Основные компоненты
- Базовый класс `SyntheticControl`
- Оценщики:
  - Классический Synthetic Control
  - Synthetic Difference-in-Differences
  - Взвешенный Synthetic Control
- Утилиты для:
  - Предобработки данных
  - Валидации входных данных
  - Вычисления метрик качества
- Визуализация результатов

## 2. Этапы разработки

### Этап 1: Базовая структура и тестирование
1. Создание базовой структуры проекта
2. Настройка окружения разработки
3. Создание базового класса `SyntheticControl`
4. Написание unit-тестов для базового класса

### Этап 2: Реализация основных оценщиков
1. Реализация классического Synthetic Control
2. Реализация Synthetic Difference-in-Differences
3. Написание unit-тестов для каждого оценщика
4. Интеграционные тесты

### Этап 3: Утилиты и предобработка
1. Реализация функций предобработки данных
2. Создание валидаторов входных данных
3. Реализация метрик качества
4. Тестирование утилит

### Этап 4: Визуализация
1. Реализация функций визуализации
2. Создание примеров использования
3. Тестирование визуализации

### Этап 5: Документация и примеры
1. Написание документации
2. Создание примеров использования
3. Создание Jupyter notebooks с примерами

## 3. Тестирование

### 3.1 Unit-тесты
- Тестирование базового класса
- Тестирование каждого оценщика
- Тестирование утилит
- Тестирование визуализации

### 3.2 Интеграционные тесты
- Тестирование полного пайплайна
- Тестирование на реальных данных
- Тестирование производительности

### 3.3 Тестовые данные
- Синтетические данные
- Реальные данные (smoking.csv)
- Данные для edge cases

## 4. Требования к коду

### 4.1 Качество кода
- Соблюдение PEP 8
- Типизация (type hints)
- Документация (docstrings)
- Логирование

### 4.2 Производительность
- Оптимизация вычислений
- Векторизация операций
- Кэширование промежуточных результатов

## 5. Документация

### 5.1 API документация
- Описание всех классов и методов
- Примеры использования
- Описание параметров

### 5.2 Руководство пользователя
- Установка
- Базовое использование
- Расширенные примеры
- FAQ

## 6. Публикация

### 6.1 Подготовка к публикации
- Настройка setup.py
- Создание пакета
- Тестирование установки

### 6.2 Публикация
- PyPI
- GitHub
- Документация на ReadTheDocs 

## 7. Реализованные методы

### 7.1 Классический Synthetic Control
Классический метод Synthetic Control (Abadie & Gardeazabal, 2003) позволяет создать синтетическую контрольную группу как взвешенную комбинацию доступных контрольных единиц. Веса оптимизируются таким образом, чтобы минимизировать различия между обработанной единицей и синтетическим контролем в период до воздействия.

### 7.2 Synthetic Difference-in-Differences (SDID)
Метод Synthetic Difference-in-Differences (Arkhangelsky et al., 2021) объединяет идеи методов Synthetic Control и Difference-in-Differences. Этот метод использует веса как для единиц, так и для временных периодов, что позволяет более точно оценивать эффект воздействия в тех случаях, когда классические методы могут давать смещенные оценки.

Основные особенности:
- Оптимизация весов как для единиц наблюдения, так и для временных периодов
- Регуляризация для улучшения устойчивости оценок
- Оценка стандартных ошибок с помощью плацебо-подхода
- Возможность использования нескольких обработанных единиц

### 7.3 Дополнительные функции
- Визуализация результатов
- Статистические тесты
- Оценка качества подгонки 